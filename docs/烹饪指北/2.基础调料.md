# 调料

在这部分，多数是做一些基础配置（多个项目通用的配置抽象出来成为一个子包）以及组织工程结构的操作，

- tsconfig
- lint-configs
  - eslint-config
  - prettier-config
  - commitlint-config
  - stylelint-config
- tailwind-config
- vite-config

它们的统一命名格式为：`@o-oyic/xxx`

> 其中的tailwind和vite的配置，我先定义好了放在这里，等到需要这些内容的子包开始了之后，才到这里做配置。

## 目录结构

创建一个文件夹，并让它成为monorepo工作区，并在根目录下创建`pnpm-workspace.yaml`文件：

```yaml
packages:
  - 'apps/*'
  - 'packages/*'
  - 'internal/*'
  - 'docs/*'
```

也就是需要创建上面的这么多个子包嗷

### 工作区

添加一个工作区的配置文件，为了好找，也为了有个映射关系，直接创建一✋🏻工作区文件：o-oyic.code-workspace，将目前已有的或在计划中的子包放进去（没有的后面再补嗷）

```json
{
  "folders": [
    {
      "name": "@o-oyic/tsconfig",
      "path": "internal/lint-config/tsconfig"
    },
    {
      "name": "@o-oyic/eslint-config",
      "path": "internal/lint-config/eslint-config"
    }
  ]
}
```

## 基础配置

### tsconfig

由一堆json文件组成，不需要打包构建，直接在`package.json`中定义导出文件的列表即可

### lint-configs

lint项目是多个配置的集合，包含了：

- eslint
- prettier
- stylelint
- commitlint

在这个环节定义的lint配置，需要注意两点：

- 需要在父包的package.json中定义公共包，子包的name要和父包对应上

```json
{
  "dependencies": {
    // ...
    "@o-oyic/eslint-config": "workspace:*",
    "@o-oyic/prettier-config": "workspace:*",
    "@o-oyic/stylelint-config": "workspace:*",
    "@o-oyic/commitlint-config": "workspace:*"
  }
}
```

- 在子包内要注意导出的文件

```json
{
  "name": "@o-oyic/xxx-config",
  "main": "${path}", // path 为实际导出文件路径
  "module": "${path}",
  "types": "${path}",
  "exports": {
    ".": {
      "import": "${path}",
      "require": "${path}"
    }
  }
}
```

需要定义的配置：

- javascript
- typescript
- vue
- react
- command
- import
- ignore

统一用`interopDefault`方法导入依赖，返回`Promise`，在入口处`index`文件统一导出

项目在运行`pnpm install`的时候，可以利用`pnpm`的生命周期：

- preinstall：在安装依赖项之前运行。
- install：在安装依赖项时运行。
- postinstall：在安装依赖项之后运行。

在`postinstall`进行工作区的依赖构建，在主包的`package.json`里面定义脚本

```json
{
  "scripts": {
    "preinstall": "npx only-allow pnpm", // 只允许使用pnpm
    // install 安装依赖
    "postinstall": "pnpm -r run stub --if-present" // 运行子包的stub脚本
  }
}
```

在安装依赖的前后做一些准备工作：

- 安装前只允许pnpm作为包管理工具
- 通过工作区的依赖`"@o-oyic/eslint-config": "workspace:*"`，将子包作为依赖安装在工作区：`node_modules/@o-oyic/xxx`
- 安装后运行子包的的`stub`脚本，会将`lint`下需要构建的子包打包构建在工作区

### 集成Husky（哈撒给）

在提交或推送时自动检查你的提交消息、代码并运行测试，发生错误时阻止提交或推送。

#### 初始化

```shell
pnpm exec husky init
```

它在 .husky/ 中创建一个 pre-commit 脚本，并在 package.json 中更新 prepare 脚本。

在这个基础上，再做多点检查，后面这个项目是会上CI/CD的，我希望只在本地的环境上，进行校验，在CI的环境上，不做校验

需要更新 prepare 脚本，加上校验CI环境的命令

```json
{
  "scripts": {
    "prepare": "is-ci || husky"
  }
}
```

### 编写脚本执行lint

编写脚本执行lint，脚本相关的内容会定义在`scripts`子包内，这里面会放一些关于构建打包部署的脚本一类的文件

cli脚本主要的思路有：

- lint
- update version
- deploy

在lint阶段，我们使用可执行脚本的方式，将命令暴漏出去给到顶层包去使用，至于怎么编写可执行脚本，你舅想吧

需要在cli提供bin文件、lint脚本、unbuild构建文件

```js
#!/usr/bin/env node

import('../dist/index.mjs');
```

我将一系列的cli脚本命名为oci（o-oyci CLI）

所以在顶层的package.json就要用oci来执行脚本

```json
{
  // ...
  "scripts": {
    //...
    "lint": "oci lint",
    "format": "oci lint --format"
  }
}
```

到目前为止已经准备了可执行脚本（bin）、lint脚本，接下来是结合 commitlint + lint-staged + husky，在提交前进行lint检查

#### lint-staged

这是针对暂存区的文件进行lint的插件，因为我们提交一次，不需要更改全部文件，太耗时且容易改坏其他文件的格式

同样的配方，需要在顶层定义配置文件`.lintstagedrc.mjs`

然后我们就可以对暂存区的文件进行校验，这个插件直接执行命令 `pnpm exec lint-staged`

但是为了结合提交前的暂存区校验，我们要将这条命令写入 husky的`pre-commit`里面

#### commitlint

依然是在lint-config定义脚本，然后导出

接着在顶层定义配置文件`.commitlintrc.mjs`

#### pre-commit

在初始化husky的时候，它已经帮我们生成了配置文件`.husky/pre-commit`

我们在里面使用上需要的命令，包含了update version、lint-staged

```shell
pnpm exec lint-staged
```

还没完，我们还需要将提交方式也更改下，需要在顶层的package.json修改一下配置

```json
{
  //...
  "config": {
    "commitizen": {
      "path": "node_modules/cz-git"
    }
  }
}
```

将git提交方式交给cz-git来托管，它会拦截我们的提交，按照commitlint定义的规范去一步步完成提交

最后，定义脚本，每次在commit文件的时候，运行命令：`pnpm commit`，就可以达到我们想要的最终效果

```json
{
  "scripts": {
    //...
    "commit": "git-cz"
  }
}
```

此致，整个项目架构的调料已经准备完成，接下来是 萌萌进攻 基建支持了
